<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Snake Evolution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { -webkit-tap-highlight-color: transparent; }
    body {
      background: linear-gradient(135deg, #e8f4ea 0%, #d4e8d7 50%, #c5e1c8 100%);
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #1b5e20;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .game-wrapper {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 12px;
      width: 100%;
      max-width: 100%;
    }
    .stats-side {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
      min-width: 70px;
    }
    .stats-side .stat {
      font-size: 0.85rem;
      font-weight: 600;
      color: #2e7d32;
      background: rgba(255,255,255,0.8);
      padding: 6px 10px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(46,125,50,0.15);
    }
    .stats-side .stat strong { color: #1b5e20; }
    .game-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    h1 {
      font-size: clamp(1rem, 3vw, 1.3rem);
      color: #1b5e20;
      letter-spacing: 1px;
    }
    .canvas-wrap {
      position: relative;
      width: min(82vw, 82dvw, 380px);
      max-width: 100%;
      aspect-ratio: 1;
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #f1f8e9 0%, #dcedc8 100%);
      border: 3px solid #81c784;
      border-radius: 16px;
      box-shadow: 0 4px 20px rgba(129,199,132,0.4), inset 0 0 0 1px rgba(255,255,255,0.5);
      touch-action: none;
    }
    .controls-side {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      min-width: 100px;
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto auto auto;
      gap: 8px;
    }
    .btn {
      width: clamp(52px, 16vw, 60px);
      height: clamp(52px, 16vw, 60px);
      min-width: 52px;
      min-height: 52px;
      font-size: 22px;
      background: rgba(129,199,132,0.4);
      border: 2px solid #66bb6a;
      border-radius: 12px;
      color: #2e7d32;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 10px rgba(102,187,106,0.3);
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active { background: rgba(102,187,106,0.6); transform: scale(0.95); }
    .btn-up { grid-column: 2; }
    .btn-down { grid-column: 2; grid-row: 3; }
    .btn-left { grid-column: 1; grid-row: 2; }
    .btn-right { grid-column: 3; grid-row: 2; }
    @media (max-width: 500px) {
      .game-wrapper { flex-direction: column; align-items: stretch; }
      .stats-side { flex-direction: row; flex-wrap: wrap; justify-content: flex-start; min-width: auto; order: 1; }
      .game-area { order: 2; }
      .controls-side { order: 3; justify-content: flex-end; margin-right: 8px; }
      .btn { width: 58px; height: 58px; min-width: 58px; min-height: 58px; font-size: 24px; }
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(232,245,233,0.97);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      z-index: 100;
    }
    .overlay.hidden { display: none; }
    .overlay h2 { font-size: 1.5rem; color: #1b5e20; }
    .overlay p { font-size: 0.95rem; color: #2e7d32; }
    .overlay button {
      padding: 14px 32px;
      font-size: 1rem;
      background: linear-gradient(135deg, #66bb6a, #43a047);
      border: none;
      border-radius: 14px;
      color: white;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(67,160,71,0.4);
    }
    .overlay button:active { transform: scale(0.98); }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <div class="stats-side">
      <div class="stat">üçé <strong id="score">0</strong></div>
      <div class="stat">üèÜ <strong id="record">0</strong></div>
      <div class="stat">‚≠ê <strong id="level">1</strong></div>
    </div>
    <div class="game-area">
      <h1>Snake Evolution</h1>
      <div class="canvas-wrap">
        <canvas id="gameCanvas"></canvas>
      </div>
    </div>
    <div class="controls-side">
      <div class="controls">
        <button class="btn btn-up" id="btnUp">‚ñ≤</button>
        <button class="btn btn-down" id="btnDown">‚ñº</button>
        <button class="btn btn-left" id="btnLeft">‚óÄ</button>
        <button class="btn btn-right" id="btnRight">‚ñ∂</button>
      </div>
    </div>
  </div>

  <div id="startScreen" class="overlay">
    <h2>üêç Snake Evolution</h2>
    <p>–°—Ç—Ä–µ–ª–∫–∏, –∫–Ω–æ–ø–∫–∏ –∏–ª–∏ —Å–≤–∞–π–ø ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</p>
    <p>üçé –Ø–±–ª–æ–∫–æ ‚Äî —Ä–∞—Å—Ç—ë—à—å. ü™® –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –ø–æ—è–≤–ª—è—é—Ç—Å—è —Å —É—Ä–æ–≤–Ω–µ–º</p>
    <p>–ë–æ–Ω—É—Å—ã: üëª —Å–∫–≤–æ–∑—å —Å—Ç–µ–Ω—ã ‚Ä¢ üêå –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ ‚Ä¢ üí£ —Ä–∞–∑—Ä—É—à–∏—Ç—å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è ‚Ä¢ ü™ô –∑–æ–ª–æ—Ç–æ</p>
    <button id="startBtn">–ò–≥—Ä–∞—Ç—å</button>
  </div>

  <div id="gameOverScreen" class="overlay hidden">
    <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
    <p>–°—á—ë—Ç: <span id="finalScore">0</span></p>
    <button id="restartBtn">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
  </div>

  <script>
    (function() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const gridSize = 16;
      let cols = 20;
      let rows = 20;

      function resizeCanvas() {
        const wrap = canvas.parentElement;
        const size = Math.min(wrap.clientWidth, wrap.clientHeight) || 320;
        const cellCount = Math.max(10, Math.floor(size / gridSize));
        const pixelSize = cellCount * gridSize;
        canvas.width = pixelSize;
        canvas.height = pixelSize;
        cols = cellCount;
        rows = cellCount;
      }

      let snake = [];
      let direction = { x: 1, y: 0 };
      let nextDirection = { x: 1, y: 0 };
      let apple = null;
      let bonus = null;
      let obstacles = [];
      let score = 0;
      let level = 1;
      let record = parseInt(localStorage.getItem('snakeRecord') || '0', 10);
      let pendingSegments = 0;
      let gameLoop = null;
      let lastMove = 0;
      let baseSpeed = 220;
      let currentSpeed = 220;
      let gameOver = false;
      let ghostMode = false;
      let ghostEndTime = 0;
      let freezeMode = false;
      let freezeEndTime = 0;
      let isPaused = false;
      let lastBonusTry = 0;

      const BONUS_CHANCE = 0.12;
      const GOLD_CHANCE = 0.06;
      const BONUS_TYPES = {
        ghost: { emoji: 'üëª', label: '–°–∫–≤–æ–∑—å —Å—Ç–µ–Ω—ã!', duration: 8000 },
        freeze: { emoji: 'üêå', label: '–ó–∞–º–µ–¥–ª–µ–Ω–∏–µ', duration: 8000 },
        bomb: { emoji: 'üí£', label: '–ë—É–º!', duration: 0 },
        gold: { emoji: 'ü™ô', label: '+50', points: 50 }
      };

      function randPos() {
        return {
          x: Math.floor(Math.random() * cols),
          y: Math.floor(Math.random() * rows)
        };
      }

      function isOccupied(pos, excludeSnake = false) {
        if (!excludeSnake) {
          for (const s of snake) {
            if (s.x === pos.x && s.y === pos.y) return true;
          }
        }
        if (apple && apple.x === pos.x && apple.y === pos.y) return true;
        if (bonus && bonus.x === pos.x && bonus.y === pos.y) return true;
        for (const o of obstacles) {
          if (o.x === pos.x && o.y === pos.y) return true;
        }
        return false;
      }

      function spawnApple() {
        let pos;
        do { pos = randPos(); } while (isOccupied(pos));
        apple = pos;
      }

      function trySpawnBonus() {
        if (bonus) return;
        const r = Math.random();
        if (r < GOLD_CHANCE) {
          let pos;
          do { pos = randPos(); } while (isOccupied(pos));
          bonus = { ...pos, type: 'gold' };
        } else if (r < BONUS_CHANCE + GOLD_CHANCE) {
          const types = ['ghost', 'freeze', 'bomb'];
          const type = types[Math.floor(Math.random() * types.length)];
          let pos;
          do { pos = randPos(); } while (isOccupied(pos));
          bonus = { ...pos, type };
        }
      }

      function addObstacle() {
        let pos;
        let attempts = 0;
        do {
          pos = randPos();
          attempts++;
          if (attempts > 100) return;
        } while (isOccupied(pos));
        obstacles.push(pos);
      }

      function initGame() {
        snake = [
          { x: Math.floor(cols / 2) - 1, y: Math.floor(rows / 2) },
          { x: Math.floor(cols / 2) - 2, y: Math.floor(rows / 2) }
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
        obstacles = [];
        score = 0;
        level = 1;
        pendingSegments = 0;
        apple = null;
        bonus = null;
        gameOver = false;
        ghostMode = false;
        freezeMode = false;
        currentSpeed = baseSpeed;
        lastBonusTry = Date.now();
        spawnApple();
        updateUI();
      }

      function updateUI() {
        document.getElementById('score').textContent = score;
        document.getElementById('record').textContent = record;
        document.getElementById('level').textContent = level;
      }

      function hitObstacle(x, y) {
        if (ghostMode) return false;
        for (const o of obstacles) {
          if (o.x === x && o.y === y) return true;
        }
        return false;
      }

      function hitSelf(head) {
        if (ghostMode) return false;
        for (let i = 1; i < snake.length; i++) {
          if (snake[i].x === head.x && snake[i].y === head.y) return true;
        }
        return false;
      }

      function wrap(pos) {
        pos.x = ((pos.x % cols) + cols) % cols;
        pos.y = ((pos.y % rows) + rows) % rows;
      }

      function moveSnake(timestamp) {
        if (gameOver || isPaused) return;
        const now = Date.now();
        if (now - lastMove < currentSpeed) {
          requestAnimationFrame(moveSnake);
          return;
        }
        lastMove = now;

        direction = { ...nextDirection };
        const head = { ...snake[0] };
        head.x += direction.x;
        head.y += direction.y;

        if (!ghostMode) wrap(head);
        else {
          if (head.x < 0) head.x = cols - 1;
          if (head.x >= cols) head.x = 0;
          if (head.y < 0) head.y = rows - 1;
          if (head.y >= rows) head.y = 0;
        }

        if (!ghostMode && (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows)) {
          endGame();
          return;
        }

        if (hitObstacle(head.x, head.y)) {
          endGame();
          return;
        }
        if (hitSelf(head)) {
          endGame();
          return;
        }

        snake.unshift(head);

        if (apple && head.x === apple.x && head.y === apple.y) {
          score += 10;
          pendingSegments += 1;
          spawnApple();
          bonus = null;
          trySpawnBonus();
          const newLevel = Math.floor(score / 80) + 1;
          if (newLevel > level) {
            level = newLevel;
            currentSpeed = Math.max(100, baseSpeed - level * 5);
            const count = Math.random() < 0.5 ? 1 : 2;
            for (let i = 0; i < count; i++) addObstacle();
          }
        } else if (bonus && head.x === bonus.x && head.y === bonus.y) {
          if (bonus.type === 'gold') {
            score += 50;
            pendingSegments += 2;
          } else if (bonus.type === 'ghost') {
            ghostMode = true;
            ghostEndTime = Date.now() + BONUS_TYPES.ghost.duration;
          } else if (bonus.type === 'freeze') {
            freezeMode = true;
            freezeEndTime = Date.now() + BONUS_TYPES.freeze.duration;
            currentSpeed = currentSpeed * 2;
          } else if (bonus.type === 'bomb' && obstacles.length > 0) {
            const toRemove = Math.min(2, obstacles.length);
            for (let i = 0; i < toRemove; i++) {
              obstacles.splice(Math.floor(Math.random() * obstacles.length), 1);
            }
          }
          bonus = null;
          trySpawnBonus();
        } else {
          if (pendingSegments > 0) {
            pendingSegments--;
          } else {
            snake.pop();
          }
        }

        if (ghostMode && Date.now() > ghostEndTime) ghostMode = false;
        if (freezeMode && Date.now() > freezeEndTime) {
          freezeMode = false;
          currentSpeed = Math.max(50, baseSpeed - level * 8);
        }

        if (score > 0 && Date.now() - lastBonusTry > 4000) {
          lastBonusTry = Date.now();
          trySpawnBonus();
        }

        if (score > record) {
          record = score;
          localStorage.setItem('snakeRecord', String(record));
        }

        updateUI();
        draw();
        requestAnimationFrame(moveSnake);
      }

      function draw() {
        ctx.fillStyle = '#f1f8e9';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(129,199,132,0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= cols; i++) ctx.beginPath(), ctx.moveTo(i * gridSize, 0), ctx.lineTo(i * gridSize, canvas.height), ctx.stroke();
        for (let j = 0; j <= rows; j++) ctx.beginPath(), ctx.moveTo(0, j * gridSize), ctx.lineTo(canvas.width, j * gridSize), ctx.stroke();
        const gs = gridSize;

        for (const o of obstacles) {
          const px = o.x * gs + 1, py = o.y * gs + 1, sz = gs - 2;
          ctx.fillStyle = '#212121';
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          ctx.shadowColor = 'rgba(0,0,0,0.4)';
          ctx.shadowBlur = 6;
          ctx.fillRect(px, py, sz, sz);
          ctx.strokeRect(px, py, sz, sz);
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.fillRect(px + 2, py + 2, sz / 3, sz / 3);
          ctx.shadowBlur = 0;
        }

        if (apple) {
          const cx = apple.x * gs + gs / 2, cy = apple.y * gs + gs / 2, r = gs / 2 - 2;
          ctx.fillStyle = '#e53935';
          ctx.shadowColor = '#c62828';
          ctx.shadowBlur = 12;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#81c784';
          ctx.beginPath();
          ctx.arc(cx, cy - r - 1, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        }

        if (bonus) {
          const bx = bonus.x * gs + gs / 2, by = bonus.y * gs + gs / 2;
          const bt = BONUS_TYPES[bonus.type];
          ctx.shadowColor = bonus.type === 'gold' ? '#ffd700' : bonus.type === 'bomb' ? '#ff5722' : bonus.type === 'ghost' ? '#9c27b0' : '#2196f3';
          ctx.shadowBlur = 10;
          ctx.font = `${gs}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(bt?.emoji || '?', bx, by);
          ctx.shadowBlur = 0;
        }

        const len = snake.length;
        snake.forEach((seg, i) => {
          const t = i / len;
          const alpha = ghostMode ? 0.6 : 0.5 + 0.5 * (1 - t);
          const px = seg.x * gs + 1, py = seg.y * gs + 1, sz = gs - 2;
          ctx.fillStyle = `rgba(46, 125, 50, ${alpha})`;
          ctx.strokeStyle = `rgba(27, 94, 32, ${alpha})`;
          ctx.lineWidth = 1;
          ctx.shadowColor = 'rgba(46,125,50,0.4)';
          ctx.shadowBlur = ghostMode ? 12 : 4;
          ctx.fillRect(px, py, sz, sz);
          ctx.strokeRect(px, py, sz, sz);
          if (i === 0) {
            const hx = seg.x * gs + gs / 2, hy = seg.y * gs + gs / 2;
            const dx = direction.x, dy = direction.y;
            let ex1, ey1, ex2, ey2, mx, my;
            if (dx === 1) { ex1 = hx + 4; ey1 = hy - 3; ex2 = hx + 4; ey2 = hy + 3; mx = hx + 2; my = hy; }
            else if (dx === -1) { ex1 = hx - 4; ey1 = hy - 3; ex2 = hx - 4; ey2 = hy + 3; mx = hx - 2; my = hy; }
            else if (dy === -1) { ex1 = hx - 3; ey1 = hy - 4; ex2 = hx + 3; ey2 = hy - 4; mx = hx; my = hy - 2; }
            else { ex1 = hx - 3; ey1 = hy + 4; ex2 = hx + 3; ey2 = hy + 4; mx = hx; my = hy + 2; }
            ctx.fillStyle = '#1b5e20';
            ctx.beginPath();
            ctx.arc(ex1, ey1, 2.5, 0, Math.PI * 2);
            ctx.arc(ex2, ey2, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(ex1 + (dx > 0 ? 0.5 : dx < 0 ? -0.5 : 0), ey1 + (dy > 0 ? 0.5 : dy < 0 ? -0.5 : 0), 1, 0, Math.PI * 2);
            ctx.arc(ex2 + (dx > 0 ? 0.5 : dx < 0 ? -0.5 : 0), ey2 + (dy > 0 ? 0.5 : dy < 0 ? -0.5 : 0), 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1b5e20';
            ctx.beginPath();
            ctx.arc(mx, my, 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        ctx.shadowBlur = 0;
      }

      function endGame() {
        gameOver = true;
        document.getElementById('finalScore').textContent = score;
        document.getElementById('gameOverScreen').classList.remove('hidden');
      }

      function setDir(dx, dy) {
        if (dx === -direction.x && dy === -direction.y) return;
        nextDirection = { x: dx, y: dy };
      }

      document.getElementById('startBtn').onclick = () => {
        document.getElementById('startScreen').classList.add('hidden');
        initGame();
        lastMove = Date.now();
        requestAnimationFrame(moveSnake);
      };

      document.getElementById('restartBtn').onclick = () => {
        document.getElementById('gameOverScreen').classList.add('hidden');
        initGame();
        lastMove = Date.now();
        requestAnimationFrame(moveSnake);
      };

      document.getElementById('btnUp').onclick = () => setDir(0, -1);
      document.getElementById('btnDown').onclick = () => setDir(0, 1);
      document.getElementById('btnLeft').onclick = () => setDir(-1, 0);
      document.getElementById('btnRight').onclick = () => setDir(1, 0);

      document.addEventListener('keydown', (e) => {
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault();
        if (e.key === 'ArrowUp') setDir(0, -1);
        if (e.key === 'ArrowDown') setDir(0, 1);
        if (e.key === 'ArrowLeft') setDir(-1, 0);
        if (e.key === 'ArrowRight') setDir(1, 0);
      });

      // –°–≤–∞–π–ø—ã –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
      let touchStart = { x: 0, y: 0 };
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchStart.x = e.touches[0].clientX;
        touchStart.y = e.touches[0].clientY;
      }, { passive: false });
      canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (!e.changedTouches[0]) return;
        const dx = e.changedTouches[0].clientX - touchStart.x;
        const dy = e.changedTouches[0].clientY - touchStart.y;
        const minSwipe = 30;
        if (Math.abs(dx) >= minSwipe || Math.abs(dy) >= minSwipe) {
          if (Math.abs(dx) > Math.abs(dy))
            setDir(dx > 0 ? 1 : -1, 0);
          else
            setDir(0, dy > 0 ? 1 : -1);
        }
      }, { passive: false });

      resizeCanvas();
      window.addEventListener('resize', () => {
        if (document.getElementById('startScreen').classList.contains('hidden') && !gameOver) return;
        resizeCanvas();
      });
    })();
  </script>
</body>
</html>
